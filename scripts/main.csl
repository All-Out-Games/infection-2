import "core:ao"

white_sprite:    Texture_Asset;
modal_bg_sprite: Texture_Asset;
button_green:    Texture_Asset;
button_red:      Texture_Asset;
button_orange:   Texture_Asset;

dust_spine: Spine_Asset;

keybind_dodge_roll: Keybind;
keybind_drop_fuel: Keybind;
keybind_sprint: Keybind;

Game_State :: enum {
    RESET_MAP;
    WAITING_FOR_PLAYERS;
    GAMEPLAY;
    END_GAME_SCREEN;
}

Player_Team :: enum {
    SURVIVOR;
    ZOMBIE;
    SPECTATOR;
}

all_zombie_spawns: [..]Entity;
all_survivor_spawns: [..]Entity;

ROUND_TIME_LIMIT :: 300.0; // 5 minutes in seconds

g_game: struct {
    state: Game_State;

    tasks: [4]Task;
    current_task: Task;
    current_task_index: int;

    winner: Player_Team;
    end_game_screen_timer: float;

    fuel_deposited: int;
    battery_delivered: bool;

    player_count_last_frame: int;
    round_countdown_timer: float;
    round_timer: float; // Time remaining in the current round
};

TASK_COMPLETION_TIME_BONUS :: 60.0;

complete_current_task :: proc() {
    g_game.current_task_index += 1;
    if g_game.current_task_index < g_game.tasks.count {
        g_game.current_task = g_game.tasks[g_game.current_task_index];
    }
    else {
        g_game.current_task = .NONE;
    }

    // Bonus time for completing a task
    g_game.round_timer += TASK_COMPLETION_TIME_BONUS;
}

server_rng: u64;

ROUND_COUNTDOWN_TIMER                           :: 10;
ROUND_COUNTDOWN_TIMER_WHEN_PLAYER_COUNT_CHANGES :: 5;

MAX_AMMO        :: 4;
AMMO_PER_SECOND :: 0.6;

get_game_manager :: proc() -> Game_Manager {
    #static game_manager: Game_Manager;
    if game_manager == null {
        foreach gm: component_iterator(Game_Manager) {
            game_manager = gm;
            break;
        }
    }
    return game_manager;
}

ao_before_scene_load :: proc() {
    white_sprite    = get_asset(Texture_Asset, "$AO/white.png");
    modal_bg_sprite = get_asset(Texture_Asset, "ui/modal_simple_white1.png");
    button_green    = get_asset(Texture_Asset, "ui/button_large_green1.png");
    button_red      = get_asset(Texture_Asset, "ui/button_large_red1.png");
    button_orange   = get_asset(Texture_Asset, "ui/button_large_yellow2.png");

    dust_spine      = get_asset(Spine_Asset, "rigs/dust_running_spine/dust_running.spine");

    keybind_dodge_roll = Keybinds.register("Roll", .SPACE);
    keybind_drop_fuel = Keybinds.register("Drop Fuel", .F);
    keybind_sprint = Keybinds.register("Sprint", .LEFT_SHIFT);

    server_rng = rng_seed((get_real_time() * 1000000000).(u64));
}

Zombie_Spawn_Point :: class : Component { }
Survivor_Spawn_Point :: class : Component { }

ao_start :: proc() {
    foreach spawn: component_iterator(Zombie_Spawn_Point) {
        all_zombie_spawns->append(spawn.entity);
    }
    foreach spawn: component_iterator(Survivor_Spawn_Point) {
        all_survivor_spawns->append(spawn.entity);
    }
}

draw_big_game_text :: proc(str: string, args: [^]any = {}) {
    ts := UI.default_text_settings();
    ts.size = 64;
    text_rect := UI.get_screen_rect()->bottom_center_rect()->offset(0, 150);
    UI.text(text_rect, ts, str, args);
}

draw_small_game_text :: proc(str: string, args: [^]any = {}) {
    ts := UI.default_text_settings();
    ts.size = 48;
    text_rect := UI.get_screen_rect()->bottom_center_rect()->offset(0, 75);
    UI.text(text_rect, ts, str, args);
}

draw_round_timer :: proc(time_remaining: float, paused: bool, pause_reason: string) {
    // Format time as M:SS
    total_seconds := max(0, time_remaining.(int));
    minutes := total_seconds / 60;
    seconds := total_seconds % 60;

    // Draw timer background
    timer_rect := UI.get_safe_screen_rect()->top_center_rect()->offset(0, -60)->grow(80, 40, 20, 40);
    UI.quad(timer_rect, white_sprite, {0, 0, 0, 0.6});

    // Draw timer text
    ts := UI.default_text_settings();
    ts.size = 48;

    if paused {
        // Pulsing yellow/gold when paused
        pulse := (sin(get_time() * 4) + 1) * 0.5;
        ts.color = {1, 0.8 + pulse * 0.2, 0.2, 1};
    }
    else if time_remaining < 30.0 {
        // Make timer red when under 30 seconds
        ts.color = {1, 0.3, 0.3, 1};
    }

    UI.text(timer_rect, ts, "%:%", {format_int(minutes, leading_zeroes=2), format_int(seconds, leading_zeroes=2)});

    if paused {
        // Draw pause reason indicator below timer
        pause_ts := UI.default_text_settings();
        pause_ts.size = 24;
        pause_ts.color = {1, 0.9, 0.3, 1};
        UI.text(timer_rect->offset(0, -35), pause_ts, pause_reason);
    }
}

begin_task_ui :: proc() -> Rect {
    return UI.get_safe_screen_rect()->left_center_rect()->offset(20, 25);
}

draw_task_title :: proc(rect: ref Rect, str: string, args: [^]any = {}) {
    ts := UI.default_text_settings();
    ts.size = 48;
    ts.halign = .LEFT;
    ts.valign = .CENTER;
    text_rect := rect->cut_top(50);
    UI.text(text_rect, ts, str, args);
}

draw_task_subtitle :: proc(rect: ref Rect, str: string, args: [^]any = {}) {
    ts := UI.default_text_settings();
    ts.size = 36;
    ts.halign = .LEFT;
    ts.valign = .CENTER;
    text_rect := rect->cut_top(35);
    UI.text(text_rect, ts, str, args);
}

draw_rect_grow_fade_out_effect :: proc(rect: Rect, time: float, color: v4) {
    effect_t := Ease.out_quart(Ease.T(time, 0.35));
    if effect_t >= 1 return;
    growth := min(rect->width() * 0.5, rect->height() * 0.5) * effect_t;
    effect_rect := rect->grow_unscaled(growth);
    color.w = 1 - effect_t;
    UI.quad(effect_rect, white_sprite, color);
}

get_all_components :: proc($T: typeid) -> []T {
    components: [..]T;
    foreach c: component_iterator(T) {
        components->append(c);
    }
    return components;
}

try_get_random_component :: proc(rng: ref u64, $T: typeid) -> T {
    components := get_all_components(T);
    if components.count == 0 {
        return null;
    }
    index := rng_range_int(ref rng, 0, components.count-1);
    return components[index];
}

ao_update :: proc(dt: float) {
    switch g_game.state {
        case .RESET_MAP: {
            foreach player: component_iterator(Player) {
                player.entity->remove_all_effects();
                player->remove_ghost_reason("spectator");
                player->remove_ghost_reason("escaped");
                player->set_team(.SURVIVOR);
                player.is_on_boat = false;
                respawn_player(player);
            }
            foreach fuel: component_iterator(Fuel_Canister) {
                fuel.entity->destroy();
            }
            foreach fuel: component_iterator(Boat_Battery) {
                fuel.entity->destroy();
            }
            foreach charger: component_iterator(Battery_Charger) {
                charger.is_charging = false;
            }

            // Reset trolley
            if trolley := get_trolley(); trolley != null {
                reset_trolley(trolley);
            }

            // Reset game state
            g_game.fuel_deposited = 0;
            g_game.battery_delivered = false;

            // spawn fuel canisters
            {
                // Collect all spawn points into an array
                fuel_spawn_points := get_all_components(Fuel_Spawn_Point);
                rng_shuffle(ref server_rng, fuel_spawn_points);

                // Spawn canisters at the first REQUIRED_FUEL_CANISTERS spawn points
                canisters_to_spawn := min(REQUIRED_FUEL_CANISTERS, fuel_spawn_points.count);
                canister_prefab := get_asset(Prefab_Asset, "fuel_canister.prefab");
                for i: 0..canisters_to_spawn-1 {
                    spawn_point := fuel_spawn_points[i];
                    canister_entity := Scene.instantiate(canister_prefab, spawn_point.entity.world_position);
                }
            }

            // spawn battery
            {
                #static prefab := get_asset(Prefab_Asset, "Boat Battery.prefab");

                battery_spawn := try_get_random_component(ref server_rng, Boat_Battery_Spawn_Point);
                battery := Scene.instantiate(prefab, battery_spawn.entity.world_position);
            }

            g_game.state = .WAITING_FOR_PLAYERS;
        }
        case .WAITING_FOR_PLAYERS: {
            player_count := 0;
            foreach player: component_iterator(Player) {
                player_count += 1;
            }
            defer g_game.player_count_last_frame = player_count;

            REQUIRED_PLAYERS :: 3;
            if player_count < REQUIRED_PLAYERS {
                draw_big_game_text("Waiting for players...");
                draw_small_game_text("% / %", {player_count, REQUIRED_PLAYERS});
            }
            else {
                if g_game.player_count_last_frame < REQUIRED_PLAYERS {
                    g_game.round_countdown_timer = ROUND_COUNTDOWN_TIMER.(float);
                    if Game.is_launched_from_editor() {
                        g_game.round_countdown_timer = 1;
                    }
                }
                else {
                    if g_game.player_count_last_frame != player_count {
                        g_game.round_countdown_timer = max(g_game.round_countdown_timer, ROUND_COUNTDOWN_TIMER_WHEN_PLAYER_COUNT_CHANGES.(float));
                    }
                }
                g_game.round_countdown_timer -= dt;

                draw_big_game_text("Starting round in %s...", {g_game.round_countdown_timer.(int) + 1});
                draw_small_game_text("% players", {player_count});

                if g_game.round_countdown_timer <= 0 {
                    g_game.round_countdown_timer = 0;
                    players := new(Player, player_count);
                    player_index := 0;
                    foreach player: component_iterator(Player) {
                        players[player_index] = player;
                        player_index += 1;
                        player->set_team(.SURVIVOR);
                    }

                    rng_shuffle(ref server_rng, players);
                    zombie_count := max(1, player_count / 5);
                    for i: 0..zombie_count-1 {
                        players[i]->set_team(.ZOMBIE);
                    }
                    g_game.state = .GAMEPLAY;

                    for player: players {
                        respawn_player(player);

                        // Show round start intro animation
                        intro_effect := new(Round_Start_Animation_Effect);
                        player.entity->set_active_effect(intro_effect);
                    }

                    g_game.tasks[0] = .FUEL_CANISTERS;
                    g_game.tasks[1] = .CHARGE_BATTERY;
                    g_game.tasks[2] = .PUSH_TROLLEY;
                    g_game.tasks[3] = .TAKEOFF;
                    g_game.current_task_index = 0;
                    g_game.current_task = g_game.tasks[g_game.current_task_index];
                    g_game.round_timer = ROUND_TIME_LIMIT;
                }
            }
        }
        case .GAMEPLAY: {
            // Decrement round timer (paused while battery is charging or trolley is being pushed)
            timer_paused := false;
            timer_pause_reason := "";

            battery := get_boat_battery();
            if battery != null && battery.state == .CHARGING {
                timer_paused = true;
                timer_pause_reason = "CHARGING";
            }

            if g_game.current_task == .PUSH_TROLLEY && is_trolley_being_pushed() {
                timer_paused = true;
                timer_pause_reason = "PUSHING";
            }

            if !timer_paused {
                g_game.round_timer -= dt;
            }

            survivors_left := 0;
            zombies_left := 0;
            foreach player: component_iterator(Player) {
                if player.team == .SURVIVOR && player.health.is_dead == false {
                    survivors_left += 1;
                }
                if player.team == .ZOMBIE {
                    zombies_left += 1;
                }
            }

            end_game :: proc(winner: Player_Team) {
                g_game.winner = winner;

                if Game.is_server() {
                    switch winner {
                        case .SURVIVOR: {
                            Save.increment_game_int("survivor_wins_v5", 1);
                        }
                        case .ZOMBIE: {
                            Save.increment_game_int("zombie_wins_v5", 1);
                        }
                    }
                }

                g_game.state = .END_GAME_SCREEN;
                foreach player: component_iterator(Player) {
                    switch winner {
                        case .SURVIVOR: {
                            if player.team == .ZOMBIE {
                                player->add_notification("Zombies lose!");
                            }
                            else {
                                player->add_notification("Survivors win!");
                            }
                        }
                        case .ZOMBIE: {
                            if player.team == .ZOMBIE {
                                player->add_notification("Zombies win!");
                            }
                            else {
                                player->add_notification("Survivors lose!");
                            }
                        }
                    }
                }
            }

            // Count survivors who escaped
            survivors_escaped := 0;
            foreach player: component_iterator(Player) {
                if player.is_on_boat {
                    survivors_escaped += 1;
                }
            }

            // All survivors are either dead or escaped - time to end the game
            all_survivors_resolved := (survivors_left == 0);

            switch {
                case zombies_left == 0: {
                    // All zombies left the game - survivors win!
                    end_game(.SURVIVOR);
                }
                case g_game.round_timer <= 0: {
                    // Time ran out - survivors win if any escaped, otherwise zombies win
                    if survivors_escaped > 0 {
                        end_game(.SURVIVOR);
                    }
                    else {
                        end_game(.ZOMBIE);
                    }
                }
                case all_survivors_resolved: {
                    // All survivors are dead or escaped
                    if survivors_escaped > 0 {
                        end_game(.SURVIVOR);
                    }
                    else {
                        end_game(.ZOMBIE);
                    }
                }
                case: {
                    local_player, _ := Game.get_local_player();

                    // Draw round timer at top of screen
                    draw_round_timer(g_game.round_timer, timer_paused, timer_pause_reason);

                    // Draw current task objective
                    if local_player != null {
                        switch local_player.team {
                            case .ZOMBIE: {
                                survivors_left := 0;
                                foreach player: component_iterator(Player) {
                                    if player.team == .SURVIVOR && player.health.is_dead == false {
                                        survivors_left += 1;
                                    }
                                }

                                rect := begin_task_ui();
                                draw_task_title(ref rect, "Eliminate all Survivors");
                                draw_task_subtitle(ref rect, "Survivors left: %", {survivors_left});
                            }
                            case .SURVIVOR: {
                                switch g_game.current_task {
                                    case .FUEL_CANISTERS: {
                                        rect := begin_task_ui();
                                        draw_task_title(ref rect, "Collect Fuel Canisters");
                                        draw_task_subtitle(ref rect, "Fuel: % / %", {g_game.fuel_deposited, REQUIRED_FUEL_CANISTERS});
                                    }
                                    case .CHARGE_BATTERY: {
                                        rect := begin_task_ui();
                                        draw_task_title(ref rect, "Charge the Battery");
                                        battery := get_boat_battery();
                                        if battery != null {
                                            switch battery.state {
                                                case .UNCHARGED: {
                                                    draw_task_subtitle(ref rect, "Bring battery to charger");
                                                }
                                                case .CHARGING: {
                                                    progress := battery.charge_t * 100;
                                                    draw_task_subtitle(ref rect, "Charging: %0%%", {format_float(progress, decimals=0)});
                                                }
                                                case .CHARGED: {
                                                    draw_task_subtitle(ref rect, "Bring battery to trolley!");
                                                }
                                            }
                                        }
                                    }
                                    case .PUSH_TROLLEY: {
                                        rect := begin_task_ui();
                                        draw_task_title(ref rect, "Push the Trolley!");
                                        if trolley := get_trolley(); trolley != null {
                                            if trolley.is_being_pushed {
                                                draw_task_subtitle(ref rect, "Keep pushing to the trolley!");
                                            }
                                            else {
                                                draw_task_subtitle(ref rect, "Stay near the trolley to push");
                                            }
                                        }
                                    }
                                    case .TAKEOFF: {
                                        takeoff: Takeoff_Station;
                                        foreach c: component_iterator(Takeoff_Station) {
                                            takeoff = c;
                                            break;
                                        }

                                        rect := begin_task_ui();
                                        draw_task_title(ref rect, "Escape on the boat!");

                                        // Count escaped survivors
                                        escaped_count := 0;
                                        alive_count := 0;
                                        foreach p: component_iterator(Player) {
                                            if p.is_on_boat {
                                                escaped_count += 1;
                                            }
                                            else if p.team == .SURVIVOR && !p.health.is_dead {
                                                alive_count += 1;
                                            }
                                        }
                                        draw_task_subtitle(ref rect, "Escaped: %", {escaped_count});
                                        draw_task_subtitle(ref rect, "Survivors remaining: %", {alive_count});
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
        case .END_GAME_SCREEN: {
            g_game.end_game_screen_timer += dt;
            maybe_local, _ := Game.get_local_player();
            if maybe_local != null {
                UI.push_layer(-1000);
                defer UI.pop_layer();
                switch g_game.winner {
                    case .SURVIVOR: {
                        if maybe_local.team == .ZOMBIE {
                            UI.quad(UI.get_screen_rect(), white_sprite, {1, 0, 0, 0.1});
                        }
                        else {
                            UI.quad(UI.get_screen_rect(), white_sprite, {0, 1, 0, 0.1});
                        }
                    }
                    case .ZOMBIE: {
                        if maybe_local.team == .ZOMBIE {
                            UI.quad(UI.get_screen_rect(), white_sprite, {0, 1, 0, 0.1});
                        }
                        else {
                            UI.quad(UI.get_screen_rect(), white_sprite, {1, 0, 0, 0.1});
                        }
                    }
                }
            }

            if g_game.end_game_screen_timer >= 5.0 {
                g_game = {};
            }
        }
    }
}

get_random :: proc(rng: ref u64, array: []$T) -> T {
    index := rng_range_int(ref rng, 0, array.count-1);
    return array[index];
}

respawn_player :: proc(using player: Player) {
    player.entity->remove_all_effects();
    player.health->set_max_health(1, true);

    switch team {
        case .SURVIVOR: {
            spawn := get_random(ref server_rng, all_survivor_spawns);
            offset := v2{rng_range_float(ref server_rng, -0.5, 0.5), rng_range_float(ref server_rng, -0.5, 0.5)};
            player.entity->set_local_position(spawn.world_position + offset);
        }
        case .ZOMBIE: {
            valid_spawns: [..]Entity;
            for spawn: all_zombie_spawns {
                spawn_ok := true;
                foreach player: component_iterator(Player) if player.team == .SURVIVOR {
                    if in_range(spawn.world_position - player.entity.world_position, 10) {
                        spawn_ok = false;
                        break;
                    }
                }
                if spawn_ok {
                    valid_spawns->append(spawn);
                }
            }

            if valid_spawns.count > 0 {
                index := rng_range_int(ref server_rng, 0, valid_spawns.count-1);
                spawn := valid_spawns[index];
                player.entity->set_local_position(spawn.world_position);
            }
            else {
                index := rng_range_int(ref server_rng, 0, all_zombie_spawns.count-1);
                spawn := all_zombie_spawns[index];
                player.entity->set_local_position(spawn.world_position);
            }
        }
    }
}

Game_Manager :: class : Component {
    main_navmesh:    Navmesh @ao_serialize;
    trolley_navmesh: Navmesh @ao_serialize;
    bullet_navmesh:  Navmesh @ao_serialize;

    test_string: string @ao_serialize;

    ao_start :: method() {
        log("test string: %", {test_string});
    }
}

// On mobile: press and and drag to aim, activate on release
// On PC: always aiming, click to activate
Shoot_Ability :: class : Ability_Base {
    on_init :: method() {
        name = "Shoot";
        disable_keybind = true;
        is_aimed_ability = true;
    }

    on_update :: method(params: ref Ability_Update_Params) {
        activation := Ability_Utilities.full_update_aimed_ability(player, ref params);
        if activation.activate {
            current_cooldown = 0.5;
            sfx := SFX.default_sfx_desc();
            sfx->set_position(player.entity.local_position);
            sfx.volume_perturb = 0.2;
            sfx.speed_perturb = 0.1;
            if player.current_ammo > 0 {
                player.current_ammo -= 1;
                player.current_ammo_float -= 1;
                shoot_projectile(player.entity.world_position, activation.direction * 10.0, 1, 0.5, player.team, player.entity);
                player.time_last_shot[player.current_ammo] = get_time();
                SFX.play(get_asset(SFX_Asset, "sfx/shoot.wav"), sfx);
            }
            else {
                player.last_failed_to_shoot_time = get_time();
                SFX.play(get_asset(SFX_Asset, "sfx/no_ammo.wav"), sfx);
            }
        }
    }
}

// On mobile: press and and drag to aim, activate on release
// On PC: always aiming, click to activate
Slash_Ability :: class : Ability_Base {
    on_init :: method() {
        name = "Slash";
        // icon = get_asset(Texture_Asset, "icons/coin.png");
        is_aimed_ability = true;
        disable_keybind = true;
    }

    can_use :: method() -> bool {
        return true;
    }

    on_update :: method(params: ref Ability_Update_Params) {
        activation := Ability_Utilities.full_update_aimed_ability(player, ref params);
        if activation.activate {
            current_cooldown = 1;

            effect := new(Slash_Effect);
            effect.direction = activation.direction;
            player.entity->set_active_effect(effect);
        }
    }
}

Slash_Effect :: class : Effect_Base {
    direction: v2;
    original_friction: float;
    already_hit_list: [..]Player;

    effect_start :: method() {
        player_specific.disable_movement_inputs = true;
        player->player_set_trigger("attack");
        original_friction = player.agent.friction;
        player.agent.friction = 0;
        player->set_facing_right(direction.x > 0);
        {
            sfx := SFX.default_sfx_desc();
            sfx->set_position(player.entity.world_position);
            sfx.volume = 0.75;
            sfx.volume_perturb = 0.1;
            sfx.speed_perturb = 0.2;
            SFX.play(get_asset(SFX_Asset, "sfx/slash.wav"), sfx);
        }
    }

    effect_update :: method(dt: float) {
        foreach other: component_iterator(Player) {
            if other.team == player.team continue;
            if other.team != .SURVIVOR continue;
            if in_range(other.entity.world_position - player.entity.world_position, 0.75) {
                already_hit := false;
                for hit: already_hit_list {
                    if hit == other {
                        already_hit = true;
                        break;
                    }
                }
                if already_hit {
                    continue;
                }
                other->take_damage(1);
                already_hit_list->append(other);
                {
                    sfx := SFX.default_sfx_desc();
                    sfx->set_position(other.entity.world_position);
                    sfx.volume = 0.75;
                    sfx.volume_perturb = 0.1;
                    sfx.speed_perturb = 0.2;
                    SFX.play(get_asset(SFX_Asset, "sfx/stabbed.wav"), sfx);
                }
            }
        }

        player.agent.velocity = direction * 8;
        if get_elapsed_time() > 0.25 {
            remove_effect(false);
            return;
        }
    }

    effect_end :: method(interrupt: bool) {
        player.agent.friction = original_friction;
        player->player_set_trigger("RESET");
    }
}

// Drop item ability - shown when carrying any item
Drop_Item_Ability :: class : Ability_Base {
    on_init :: method() {
        name = "Drop";
        icon = get_asset(Texture_Asset, "icons/fuel.png");
        keybind_override = keybind_drop_fuel;
    }

    can_use :: method() -> bool {
        return is_player_carrying_item(player);
    }

    on_update :: method(params: ref Ability_Update_Params) {
        if params.clicked && params.can_use {
            item := get_player_carried_item(player);
            if item != null {
                drop_carried_item(item, player.entity.world_position);
            }
        }
    }
}

// Sprint ability - hold to move faster, uses stamina
SPRINT_DRAIN_RATE :: 0.5;
SPRINT_REGEN_RATE :: 0.2;
SPRINT_SPEED_BONUS :: 1.35;

Sprint_Ability :: class : Ability_Base {
    on_init :: method() {
        name = "Sprint";
        keybind_override = keybind_sprint;
        draw_but_dont_use_keybind = true;
    }

    can_use :: method() -> bool {
        return player.team == .SURVIVOR && player.sprint_stamina > 0;
    }

    on_update :: method(params: ref Ability_Update_Params) {
        holding := Ability_Utilities.update_holding_ability(player, ref params, keybind_sprint);
        if holding.active && player.sprint_stamina > 0 && player.team == .SURVIVOR && length_squared(player.agent.velocity) > 0.001 && !player.sprint_exhausted {
            player.is_sprinting = true;
        }
        else {
            player.is_sprinting = false;
        }
    }
}

// On mobile: press and hold and drag to aim, activate on release
// On PC: toggle on, click to activate
Dodge_Roll :: class : Ability_Base {
    on_init :: method() {
        name = "Roll";
        is_aimed_ability = true;
        keybind_override = keybind_dodge_roll;
    }

    on_update :: method(params: ref Ability_Update_Params) {
        activation := Ability_Utilities.full_update_targeted_aimed_ability(player, this, ref params);
        if activation.activate {
            current_cooldown = 1.5;
            effect := new(Roll_Effect);
            effect.direction = activation.direction;
            player.entity->set_active_effect(effect);
        }
    }
}

Roll_Effect :: class : Effect_Base {
    direction: v2;
    original_friction: float;

    effect_start :: method() {
        {
            sfx := SFX.default_sfx_desc();
            sfx->set_position(player.entity.world_position);
            sfx.volume = 0.5;
            sfx.volume_perturb = 0.1;
            sfx.speed_perturb = 0.1;
            SFX.play(get_asset(SFX_Asset, "sfx/dodge_roll.wav"), sfx);
        }
        player_specific.disable_movement_inputs = true;
        player->player_set_trigger("dodge_roll");
        original_friction = player.agent.friction;
        player.agent.friction = 0;
        player->set_facing_right(direction.x > 0);
    }

    effect_update :: method(dt: float) {
        player.agent.velocity = direction * 8;
        if get_elapsed_time() > 0.5 {
            remove_effect(false);
            return;
        }
    }

    effect_end :: method(interrupt: bool) {
        player.agent.friction = original_friction;
    }
}

Round_Start_Animation_Effect :: class : Effect_Base {
    hold_progress: float;

    effect_start :: method() {
        player_specific.freeze_player = true;
        hold_progress = 0;
    }

    effect_update :: method(dt: float) {
        TOTAL_TIME :: 10.0;

        hold_progress += dt / TOTAL_TIME;
        hold_progress = clamp(hold_progress, 0, 1);

        if player->is_local_or_server() {
            bg_tint_01 := Ease.fade_in_and_out(0.1, 1.0, hold_progress);

            UI.push_layer(1000);
            defer UI.pop_layer();

            UI.push_color_multiplier({1, 1, 1, bg_tint_01});
            defer UI.pop_color_multiplier();

            UI.quad(UI.get_screen_rect(), white_sprite, {0, 0, 0, 0.9});

            pos_01 := Ease.slide_in_and_out(0.1, 1.0, hold_progress);
            ts := UI.default_text_settings();
            ts.size = 52;
            ts.color = {1, 1, 1, 1};
            ts.word_wrap = true;
            rect := UI.get_safe_screen_rect()->offset(pos_01 * 100, 0);

            switch player.team {
                case .SURVIVOR: {
                    actual_rect := UI.text_sync(rect, ts, "Restore the boat to escape before time runs out!");
                    ts.size = 64;
                    ts.color = {0.2, 1, 0.2, 1};
                    UI.text(actual_rect->top_rect()->grow(100, 500, 0, 500), ts, "You are a Survivor.\n\n");
                }
                case .ZOMBIE: {
                    actual_rect := UI.text_sync(rect, ts, "Hunt down all survivors!\nInfect them before they escape!");
                    ts.size = 64;
                    ts.color = {1, 0.2, 0.2, 1};
                    UI.text(actual_rect->top_rect()->grow(100, 500, 0, 500), ts, "You are Infected.\n\n");
                }
                case .SPECTATOR: {
                    actual_rect := UI.text_sync(rect, ts, "Watch the action unfold!");
                    ts.size = 64;
                    ts.color = {0.7, 0.7, 0.7, 1};
                    UI.text(actual_rect->top_rect()->grow(100, 500, 0, 500), ts, "You are Spectating.\n\n");
                }
            }

            // Blocker button to detect hold-to-close
            empty_button_settings: Button_Settings;
            click_result := UI.button(UI.get_screen_rect(), empty_button_settings, {}, "");
            if click_result.pressed {
                hold_progress += dt;
                hold_progress = clamp(hold_progress, 0, 1);
            }

            // Draw hold progress bar
            ts.color = {1, 1, 1, 1};
            hold_rect_bg := UI.get_safe_screen_rect()->bottom_center_rect()->offset(0, 200)->grow(10, 150, 10, 150);

            // Calculate the filled portion width based on hold_progress
            hold_rect := hold_rect_bg->inset(2)->subrect(0, 0, hold_progress, 1);
            UI.quad(hold_rect_bg, white_sprite, {0.8, 0.8, 0.8, 1});
            UI.quad(hold_rect, white_sprite, {0.1, 0.1, 0.1, 1});

            ts.size = 28;
            close_str := "Click and hold to close";
            if player.device_kind != .PC {
                close_str = "Tap and hold to close";
            }
            UI.text(hold_rect_bg->offset(0, 35), ts, close_str);
        }

        if hold_progress >= 1 {
            remove_effect(false);
            return;
        }
    }

    effect_end :: method(interrupt: bool) {
        // Nothing special needed on end
    }
}

//
// Health Component
//

Health_Component :: class : Component {
    max_health: int @ao_serialize;
    current_health: int;

    is_dead: bool;
    last_damage_time: float;

    // Optional: show health bar above entity
    health_bar_offset: v2 @ao_serialize;

    ao_start :: method() {
        current_health = max_health;
        if health_bar_offset.x == 0 && health_bar_offset.y == 0 {
            health_bar_offset = {0, 1.5};
        }
    }

    draw_health_bar :: method(z: float) {
        UI.push_world_draw_context();
        defer UI.pop_draw_context();

        UI.push_z(z);
        defer UI.pop_z();

        // Don't show health bar if at full health
        health_percent := get_health_percent();
        // if health_percent >= 1.0 return;

        bar_pos := entity.world_position + health_bar_offset;
        bar_rect := Rect{bar_pos, bar_pos}->grow(0.1, 0.4, 0.1, 0.4);

        UI.quad(bar_rect, white_sprite, {0.01, 0.01, 0.01, 1});

        fill_rect := bar_rect->subrect(0, 0, health_percent, 1);

        color := lerp(v4{0.8, 0.1, 0.1, 1}, {0.1, 0.8, 0.1, 1}, health_percent);
        UI.quad(fill_rect, white_sprite, color);
    }

    take_damage :: method(amount: int) -> bool {
        if is_dead return false;

        current_health -= amount;

        last_damage_time = get_time();

        // Spawn damage number
        spawn_damage_number(amount, entity.world_position + v2{0, 0.5});

        if current_health <= 0 {
            current_health = 0;
            is_dead = true;
            return true; // died
        }
        return false; // still alive
    }

    heal :: method(amount: int) {
        if is_dead return;

        current_health += amount;
        if current_health > max_health {
            current_health = max_health;
        }
    }

    get_health_percent :: method() -> float {
        if max_health <= 0 return 0;
        return current_health.(float) / max_health.(float);
    }

    reset :: method() {
        current_health = max_health;
        is_dead = false;
    }

    set_max_health :: method(new_max: int, heal_to_full: bool) {
        max_health = new_max;
        if heal_to_full {
            current_health = max_health;
        }
        else if current_health > max_health {
            current_health = max_health;
        }
    }
}

//
// Damage numbers
//

Damage_Number :: class : Component {
    value: int;
    velocity: v2;
    spawn_time: float;
    lifetime: float;

    ao_update :: method(dt: float) {
        time_alive := get_time() - spawn_time;
        if time_alive >= lifetime {
            entity->destroy();
            return;
        }

        // Apply velocity with gravity
        velocity.y -= 20 * dt;
        entity->add_local_position(velocity * dt);

        // Draw the damage number
        UI.push_world_draw_context();
        defer UI.pop_draw_context();

        UI.push_layer(100);
        defer UI.pop_layer();

        rect := Rect{entity.local_position, entity.local_position}->grow(0.2, 0.4, 0.2, 0.4);

        fade_t := linear_step(lifetime-1, lifetime, time_alive);
        ts := UI.default_text_settings();
        ts.size = lerp(0.7, 0.2, fade_t);
        ts.valign = .CENTER;
        ts.halign = .CENTER;

        // Fade out towards the end of lifetime
        alpha := 1.0 - fade_t;
        ts.color = {1, 0, 0, alpha}; // Red
        ts.outline_color = {0, 0, 0, 1};
        UI.text(rect, ts, "%", {value});
    }
}

spawn_damage_number :: proc(value: int, position: v2) {
    entity := Scene.create_entity();
    entity->set_local_position(position);

    damage_number := entity->add_component(Damage_Number);
    damage_number.value = value;
    damage_number.spawn_time = get_time();
    damage_number.lifetime = 1.5;

    // Random velocity
    rng := rng_seed(entity.id);
    vel_x := rng_range_float(ref rng, -0.3, 0.3);
    vel_y := rng_range_float(ref rng, 0.75, 0.9);
    damage_number.velocity = v2{vel_x, vel_y} * 10;
}

Death_Effect :: class : Effect_Base {
    effect_start :: method() {
        player_specific.freeze_player = true;
        player->add_name_invisibility_reason("death");
        player->player_set_trigger("death");
        if Game.is_server() {
            sfx := SFX.default_sfx_desc();
            sfx->set_position(player.entity.world_position);
            sfx.volume = 0.5;
            sfx.speed_perturb = 0.15;
            SFX.play(get_asset(SFX_Asset, "sfx/death.wav"), sfx);
        }
    }

    effect_update :: method(dt: float) {
        if g_game.state == .GAMEPLAY {
            time_until_respawn := 5.0 - get_elapsed_time();
            if player->is_local() {
                draw_big_game_text("Respawning in %s", {time_until_respawn.(int) + 1});
            }
            if time_until_respawn <= 0 {
                remove_effect(false);
                return;
            }
        }
    }

    effect_end :: method(interrupt: bool) {
        player->remove_name_invisibility_reason("death");
        if player.team == .SURVIVOR {
            player->set_team(.ZOMBIE);
        }
        respawn_player(player);
        player.health->reset();
        player->player_set_trigger("RESET");
    }
}

//
// Player, mostly UI
//

Player :: class : Player_Base {
    Notification :: class {
        time: float;
        text: string;
        next: Notification;
    }

    team: Player_Team;

    upgrade_menu_open: bool;

    time_last_shot: [MAX_AMMO]float;
    last_failed_to_shoot_time: float;

    upgrade_menu_tab_index: int;

    is_on_boat: bool;

    health: Health_Component;

    notifications: [..]Notification;

    // Ammo system
    current_ammo_float: float;
    current_ammo: int;

    // Sprint system
    sprint_stamina: float;
    sprite_dust_timer: float;
    is_sprinting: bool;
    sprint_exhausted: bool;
    dust_serial: u64;
    last_exhaust_recover_time: float;
    last_exhaust_time: float;

    first_notification: Notification;
    last_notification: Notification;

    running_state: State_Machine_State;

    add_notification :: method(text: string) {
        notification := new(Notification);
        notification.text = text;
        if first_notification == null {
            first_notification = notification;
            last_notification = notification;
        }
        else {
            last_notification.next = notification;
            last_notification = notification;
        }
    }

    take_damage :: method(damage: int) {
        if health.is_dead {
            return;
        }
        if team == .SPECTATOR {
            return;
        }
        health->take_damage(damage);
        if health.is_dead {
            active_ability = null;
            effect := new(Death_Effect);
            entity->set_active_effect(effect);
        }
    }

    draw_ammo_bar :: method() {
        UI.push_world_draw_context();
        defer UI.pop_draw_context();

        UI.push_z(entity.world_position.y-0.001);
        defer UI.pop_z();

        bar_pos := entity.world_position + v2{0, 1.75};
        bar_width := 0.8;
        bar_height := 0.2;
        segment_gap := 0.02;

        bar_rect := Rect{bar_pos, bar_pos}->grow(bar_height / 2, bar_width / 2, bar_height / 2, bar_width / 2);

        // Background bar
        {
            jitter := Ease.jitter(Ease.T(get_time() - last_failed_to_shoot_time, 0.5), 8);

            bar_rect_jitter := bar_rect->offset(jitter * 0.15, 0);

            UI.quad(bar_rect_jitter, white_sprite, {0.01, 0.01, 0.01, 1});
            inner_bar := bar_rect_jitter->inset(0.04);
            UI.quad(inner_bar, white_sprite, {0.15, 0.15, 0.15, 1});

            // fill bar
            full_ammo_t := current_ammo_float / MAX_AMMO.(float);
            UI.quad(inner_bar->subrect(0, 0, full_ammo_t, 1), white_sprite, {0.4, 0.4, 0.1, 1});

            // Calculate segment dimensions
            segment_width := inner_bar->width() / MAX_AMMO.(float);

            // Draw each segment
            step_size := inner_bar->width() / MAX_AMMO.(float);
            base_segment_rect := inner_bar->left_rect()->grow_unscaled(0, segment_width, 0, 0);
            base_notch_rect   := inner_bar->left_rect()->grow(0, segment_gap, 0, segment_gap);
            for i: 0..MAX_AMMO-1 {
                segment_rect := base_segment_rect->offset_unscaled(segment_width * i.(float), 0);
                if i < current_ammo {
                    UI.quad(segment_rect, white_sprite, {0.2, 0.9, 0.9, 1});
                }

                UI.push_layer_relative(1);
                defer UI.pop_layer();
                draw_rect_grow_fade_out_effect(segment_rect, get_time() - time_last_shot[i], {0, 1, 0, 1});
            }
            for i: 0..MAX_AMMO-2 {
                notch_rect := base_notch_rect->offset_unscaled(segment_width * (i+1).(float), 0);
                UI.quad(notch_rect, white_sprite, {0.2, 0.01, 0.01, 1});
            }
        }

        // No ammo indicator
        no_ammo_t := Ease.out_quart(Ease.T(get_time() - last_failed_to_shoot_time, 0.35));
        no_ammo_rect := bar_rect->grow(0.2 * no_ammo_t);
        UI.quad(no_ammo_rect, white_sprite, lerp(v4{1, 0, 0, 1}, v4{1, 0, 0, 0}, no_ammo_t));
    }

    draw_stamina_bar :: method() {
        UI.push_world_draw_context();
        defer UI.pop_draw_context();

        UI.push_z(entity.world_position.y-0.001);
        defer UI.pop_z();

        // Position below the ammo bar
        bar_pos := entity.world_position + v2{0, 1.6};
        bar_width := 0.6;
        bar_height := 0.12;

        bar_rect := Rect{bar_pos, bar_pos}->grow(bar_height / 2, bar_width / 2, bar_height / 2, bar_width / 2);

        // Background
        UI.quad(bar_rect, white_sprite, {0.01, 0.01, 0.01, 1});
        inner_bar := bar_rect->inset(0.02);
        UI.quad(inner_bar, white_sprite, {0.15, 0.15, 0.15, 1});

        // Stamina fill
        fill_rect := inner_bar->subrect(0, 0, sprint_stamina, 1);

        // Color: yellow when full, orange when depleting
        fill_color: v4 = #expr {
            if sprint_exhausted {
                give {1, 0, 0, 1};
            }
            if is_sprinting {
                give lerp(v4{1, 0.3, 0, 1}, {1, 0.8, 0, 1}, sprint_stamina);
            }
            give lerp(v4{1, 0.3, 0, 1}, {0.3, 1, 0, 1}, sprint_stamina);
        };
        UI.quad(fill_rect, white_sprite, fill_color);

        UI.push_layer_relative(1);
        defer UI.pop_layer();

        if sprint_exhausted {
            time_since_exhaust := (get_time() - last_exhaust_time) * 0.5;
            exhaust_time_loop := time_since_exhaust % 0.5;
            draw_rect_grow_fade_out_effect(bar_rect, exhaust_time_loop,  {1, 0, 0, 1});
        }
        time_since_recover := (get_time() - last_exhaust_recover_time) * 0.5;
        draw_rect_grow_fade_out_effect(bar_rect, time_since_recover, {0, 1, 0, 1});
    }

    turn_into_spectator :: method() {
        if team != .SPECTATOR {
            set_team(.SPECTATOR);
            add_ghost_reason("spectator");
        }
    }

    ALIVE_CHANNEL :: 1u64 << 0;
    DEAD_CHANNEL  :: 1u64 << 1;

    set_team :: method(new_team: Player_Team) {
        if new_team == .SPECTATOR {
            comms_channel_listen_mask = ALIVE_CHANNEL | DEAD_CHANNEL;
            comms_channel_speak_mask = DEAD_CHANNEL;
        }
        else {
            comms_channel_listen_mask = ALIVE_CHANNEL;
            comms_channel_speak_mask = ALIVE_CHANNEL;
        }
        team = new_team;
    }

    ao_start :: method() {
        agent->set_navmesh_to_lock_to(get_game_manager().main_navmesh);

        switch g_game.state {
            case .GAMEPLAY: {
                turn_into_spectator();
            }
            case: {
                set_team(.SURVIVOR);
            }
        }

        health = entity->add_component(Health_Component);
        health->set_max_health(1, true);
        health.health_bar_offset = {0, 1.75};

        // Initialize ammo system
        current_ammo = MAX_AMMO;
        current_ammo_float = MAX_AMMO.(float);

        // Initialize sprint stamina
        sprint_stamina = 1;

        {
            animator->awaken();
            layer := animator.instance.state_machine->try_get_layer("main");
            running_state = layer->try_get_state("Run_Fast");
            assert(running_state != null, "failed to find running state");
        }
    }

    ao_update :: method(dt: float) {
        if Game.is_launched_from_editor() {
            if get_input_down(.F1, true) {
                complete_current_task();
            }
        }

        switch team {
            case .SURVIVOR: {
                if is_player_carrying_item(this) {
                    agent.movement_speed = 150;
                }
                else {
                    agent.movement_speed = 215;
                }
            }
            case .ZOMBIE: {
                agent.movement_speed = 250;
            }
            case .SPECTATOR: {
                agent.movement_speed = 450;
            }
        }

        // Apply sprint speed bonus
        if is_sprinting {
            agent.movement_speed *= SPRINT_SPEED_BONUS;
            if Game.is_launched_from_editor() {
                agent.movement_speed *= 3;
            }
        }

        // Sprint stamina drain/regen
        sprite_dust_timer = max(0.0, sprite_dust_timer - dt);
        if is_sprinting {
            if sprite_dust_timer <= 0 {
                sprite_dust_timer = 0.15;
                dust_serial += 1;
                dust_rng := rng_seed(dust_serial);
                e := Scene.create_entity();
                e->set_local_position(entity.world_position);
                e->set_local_scale(entity.local_scale * 1.5);
                animator := e->add_component(Spine_Animator);
                brightness := rng_range_float(ref dust_rng, 0.5, 1);
                animator.instance.color_multiplier = {brightness, brightness, brightness, 0.25};
                animator.instance->set_skeleton(dust_spine);
                animator.instance->set_animation("running_dust_poof", false, 0, 1);
                e->queue_for_destruction(0.5);
            }

            running_state.speed = SPRINT_SPEED_BONUS;
            if !Game.is_launched_from_editor() {
                sprint_stamina -= dt * SPRINT_DRAIN_RATE;
            }
            else {
                sprint_stamina -= dt * (SPRINT_DRAIN_RATE * 0.1);
            }
            if sprint_stamina <= 0 {
                sprint_stamina = 0;
                is_sprinting = false;
                sprint_exhausted = true;
                last_exhaust_time = get_time();
            }
        }
        else {
            running_state.speed = 1;
            sprint_stamina = min(1.0, sprint_stamina + dt * SPRINT_REGEN_RATE);
            if sprint_exhausted && sprint_stamina >= 1 {
                sprint_exhausted = false;
                last_exhaust_recover_time = get_time();
            }
        }

        // Ammo regeneration
        current_ammo_float = min(current_ammo_float + dt * AMMO_PER_SECOND, MAX_AMMO.(float));
        current_ammo = current_ammo_float.(int);

        {
            do_name_color_override = true;
            switch team {
                case .SURVIVOR: {
                    name_color_override = {0, 1, 0, 1};
                }
                case .ZOMBIE: {
                    name_color_override = {1, 0, 0, 1};
                }
                case: {
                    name_color_override = {1, 1, 1, 1};
                }
            }
        }
    }

    ao_late_update :: method(dt: float) {
        if team == .SPECTATOR {
            agent->set_navmesh_to_lock_to(null);
            camera.size = 8;
        }
        else {
            agent->set_navmesh_to_lock_to(get_game_manager().main_navmesh);
            camera.size = 5;
        }

        if is_local_or_server() && !health.is_dead {
            if g_game.state == .WAITING_FOR_PLAYERS {
                draw_ability_button(this, Shoot_Ability, 0);
                draw_ability_button(this, Dodge_Roll, 1);
                draw_ability_button(this, Sprint_Ability, 4);
            }
            else {
                if is_player_carrying_item(this) {
                    draw_ability_button(this, Drop_Item_Ability, 0);
                    draw_ability_button(this, Sprint_Ability, 4);
                }
                else {
                    switch team {
                        case .SURVIVOR: {
                            draw_ability_button(this, Shoot_Ability, 0);
                            draw_ability_button(this, Dodge_Roll, 1);
                            draw_ability_button(this, Sprint_Ability, 4);
                        }
                        case .ZOMBIE: {
                            draw_ability_button(this, Slash_Ability, 0);
                        }
                    }
                }
            }
        }

        {
            UI.push_world_draw_context();
            defer UI.pop_draw_context();

            if team == .SURVIVOR && !health.is_dead && will_draw_name() {
                draw_ammo_bar();
                draw_stamina_bar();
            }

            if g_game.state == .GAMEPLAY {
                if is_local() {
                    switch team {
                        case .SURVIVOR: {
                            tutorial_arrow_options := Tutorial_Arrow.default_options();

                            switch g_game.current_task {
                                case .FUEL_CANISTERS: {
                                    if is_player_carrying_item(this) {
                                        foreach delivery: component_iterator(Fuel_Delivery_Point) {
                                            Tutorial_Arrow.draw(this, delivery.entity.world_position, tutorial_arrow_options);
                                        }
                                    }
                                    else {
                                        foreach fuel: component_iterator(Fuel_Canister) {
                                            if !fuel.carried_item.is_picked_up {
                                                Tutorial_Arrow.draw(this, fuel.entity.world_position, tutorial_arrow_options);
                                            }
                                            else {
                                                // Someone is carrying - point to them so others know to protect
                                                if carrier := fuel.carried_item.carrier; carrier != null {
                                                    far_only_options := tutorial_arrow_options;
                                                    far_only_options.near = false;
                                                    Tutorial_Arrow.draw(this, carrier.entity.world_position, far_only_options);
                                                }
                                            }
                                        }
                                    }
                                }
                                case .CHARGE_BATTERY: {
                                    if battery := get_boat_battery(); battery != null {
                                        switch battery.state {
                                            case .UNCHARGED: {
                                                if battery.carried_item.is_picked_up {
                                                    if carrier := battery.carried_item.carrier; carrier != null {
                                                        if carrier == this {
                                                            // I'm carrying - point to charger
                                                            foreach charger: component_iterator(Battery_Charger) {
                                                                Tutorial_Arrow.draw(this, charger.entity.world_position, tutorial_arrow_options);
                                                            }
                                                        }
                                                        else {
                                                            // Someone else is carrying - point to them
                                                            far_only_options := tutorial_arrow_options;
                                                            far_only_options.near = false;
                                                            Tutorial_Arrow.draw(this, carrier.entity.world_position, far_only_options);
                                                        }
                                                    }
                                                }
                                                else {
                                                    // Point to battery
                                                    Tutorial_Arrow.draw(this, battery.entity.world_position, tutorial_arrow_options);
                                                }
                                            }
                                            case .CHARGING: {
                                                // Point to battery while charging
                                                Tutorial_Arrow.draw(this, battery.entity.world_position, tutorial_arrow_options);
                                            }
                                            case .CHARGED: {
                                                if battery.carried_item.is_picked_up {
                                                    if carrier := battery.carried_item.carrier; carrier != null {
                                                        if carrier == this {
                                                            // I'm carrying - point to trolley delivery
                                                            foreach delivery: component_iterator(Battery_Delivery_Point) {
                                                                Tutorial_Arrow.draw(this, delivery.entity.world_position, tutorial_arrow_options);
                                                            }
                                                        }
                                                        else {
                                                            // Someone else is carrying - point to them
                                                            far_only_options := tutorial_arrow_options;
                                                            far_only_options.near = false;
                                                            Tutorial_Arrow.draw(this, carrier.entity.world_position, far_only_options);
                                                        }
                                                    }
                                                }
                                                else {
                                                    // Point to battery to pick up
                                                    Tutorial_Arrow.draw(this, battery.entity.world_position, tutorial_arrow_options);
                                                }
                                            }
                                        }
                                    }
                                }
                                case .PUSH_TROLLEY: {
                                    if trolley := get_trolley(); trolley != null && !trolley.has_reached_destination {
                                        // Don't show arrow if I'm already pushing (within range)
                                        am_pushing := in_range(entity.world_position - trolley.entity.world_position, TROLLEY_SURVIVOR_RANGE);
                                        if !am_pushing {
                                            Tutorial_Arrow.draw(this, trolley.entity.world_position, tutorial_arrow_options);
                                        }
                                    }
                                }
                                case .TAKEOFF: {
                                    takeoff: Takeoff_Station;
                                    foreach c: component_iterator(Takeoff_Station) {
                                        takeoff = c;
                                        break;
                                    }
                                    if !is_on_boat {
                                        Tutorial_Arrow.draw(this, takeoff.entity.world_position, tutorial_arrow_options);
                                    }
                                }
                            }
                        }
                        case .ZOMBIE: {
                            survivor_hint_options := Tutorial_Arrow.default_options();
                            survivor_hint_options.near = false;
                            foreach other: component_iterator(Player) if other.team == .SURVIVOR && !other.health.is_dead {
                                distance := length(other.entity.world_position - entity.world_position);
                                alpha := linear_step(20, 0, distance);
                                if alpha > 0 {
                                    survivor_hint_options.alpha = alpha;
                                    Tutorial_Arrow.draw(this, other.entity.world_position, survivor_hint_options);
                                }
                            }
                        }
                    }
                }
            }
        }

        if is_local_or_server() {
            if first_notification != null {
                first_notification.time += dt;
                if first_notification.time > 3.0 {
                    first_notification = first_notification.next;
                    if first_notification == null {
                        last_notification = null;
                    }
                }
                if first_notification != null {
                    draw_big_game_text(first_notification.text);
                }
            }
        }
    }

    ao_end :: method() {
    }

    ao_can_use_interactable :: method(interactable: Interactable) -> bool {
        if health.is_dead {
            return false;
        }
        return true;
    }

    ao_can_use_ability :: method(ability: Ability_Base) -> bool {
        if health.is_dead return false;
        return true;
    }
}

Food_Projectile :: class : Component {
    sprite: Sprite_Renderer @ao_serialize;
    velocity: v2;
    lifetime: float;
    damage: int;

    team: Player_Team;

    spawn_time: float;
    owner: Entity;
    hit_radius: float;

    start_rotation: float;

    triangle_hint: int;

    ao_start :: method() {
        spawn_time = get_time();
        if hit_radius == 0 {
            hit_radius = 0.75;
        }

        rng := rng_seed(entity.id);
        start_rotation = rng_range_float(ref rng, 0, 360);
    }

    ao_update :: method(dt: float) {
        time_alive := get_time() - spawn_time;
        sprite.entity->set_local_rotation(start_rotation + time_alive * 1440);

        // Move projectile
        entity->add_local_position(velocity * dt);

        destroy_self := false;

        if !destroy_self {
            foreach player: component_iterator(Player) {
                if player.health.is_dead continue;
                if #alive(owner) && owner == player.entity continue;
                if player.team == team continue;
                if player.team != .ZOMBIE continue;
                if in_range(player.entity.world_position - entity.world_position, hit_radius) {
                    player->take_damage(1);
                    destroy_self = true;
                    {
                        sfx := SFX.default_sfx_desc();
                        sfx->set_position(player.entity.world_position);
                        sfx.volume = 0.75;
                        sfx.volume_perturb = 0.1;
                        sfx.speed_perturb = 0.2;
                        SFX.play(get_asset(SFX_Asset, "sfx/stabbed.wav"), sfx);
                    }
                    break;
                }
            }
        }

        if time_alive >= lifetime {
            destroy_self = true;
        }

        if !destroy_self {
            point: v2;
            // todo(josh): this crashes!!!:
            // if Game_Manager.bullet_navmesh->try_find_closest_point_on_navmesh(entity.world_position, &point) {
            if get_game_manager().bullet_navmesh->try_find_closest_point_on_navmesh(entity.world_position, ref point, ref triangle_hint) {
                if !in_range(point - entity.world_position, 0.01) {
                    destroy_self = true;
                }
            }
        }

        if destroy_self {
            hit_effect := get_asset(Prefab_Asset, "hit_effect.prefab");
            effect := Scene.instantiate(hit_effect);
            rng := rng_seed(entity.id);
            effect.first_child->set_local_rotation(rng_range_float(ref rng, 0, 360));
            effect->set_local_position(entity.world_position);
            effect->queue_for_destruction(0.5);
            entity->destroy();

            #static sfx := SFX.default_sfx_desc();
            sfx->set_position(entity.world_position);
            sfx.volume = 0.5;
            sfx.volume_perturb = 0.1;
            sfx.speed_perturb = 0.1;
            #static sfx_asset := get_asset(SFX_Asset, "sfx/pop.wav");
            SFX.play(sfx_asset, sfx);
        }
    }
}

shoot_projectile :: proc(spawn_position: v2, velocity: v2, damage: int, lifetime: float, team: Player_Team, owner: Entity, texture_path: string = "icons/burger.png") -> Entity {
    #static prefab := get_asset(Prefab_Asset, "food_projectile.prefab");
    entity := Scene.instantiate(prefab, spawn_position);

    projectile := entity->get_component(Food_Projectile);
    projectile.velocity = velocity;
    projectile.lifetime = lifetime;
    projectile.damage = damage;
    projectile.owner = owner;
    return entity;
}

//
// Tasks
//

Task :: enum {
    NONE;

    FUEL_CANISTERS;
    CHARGE_BATTERY;
    PUSH_TROLLEY;
    TAKEOFF;
}

Takeoff_Station :: class : Component {
    interactable: Interactable @ao_serialize;

    ao_start :: method() {
        interactable->set_listener(this);
    }

    can_use :: method(player: Player) -> bool {
        return g_game.current_task == .TAKEOFF && player.team == .SURVIVOR && !player.is_on_boat;
    }

    on_interact :: method(player: Player) {
        player.is_on_boat = true;
        player->turn_into_spectator();
        player->add_notification("You escaped!");

        // Notify all players
        foreach p: component_iterator(Player) {
            if p != player {
                p->add_notification(format_string("A survivor escaped!", {}));
            }
        }
    }
}

//
// Fuel Canister Task
//

REQUIRED_FUEL_CANISTERS :: 3;

//
// Carried Item (shared carrying logic for Fuel_Canister, Boat_Battery, etc.)
//

Carried_Item :: class : Component {
    item_sprite: Sprite_Renderer @ao_serialize;
    shadow_sprite: Sprite_Renderer @ao_serialize;
    interactable: Interactable @ao_serialize;

    is_picked_up: bool;
    carrier: Player;
    last_carrier_position: v2;
    shadow_scale: v2;

    pickup_sfx: string;
    drop_sfx: string;
    pickup_notification: string;

    ao_start :: method() {
        shadow_scale = shadow_sprite.entity.local_scale;
    }

    ao_late_update :: method(dt: float) {
        if is_picked_up && carrier != null {
            if #alive(carrier) {
                last_carrier_position = carrier.entity.world_position;
            }
            if !#alive(carrier) || carrier.health.is_dead {
                // Carrier died or disconnected, drop the item
                drop_carried_item(this, last_carrier_position);
            }
            else {
                // Follow the carrier
                vector := normalize_vector_to_radius(entity.local_position - carrier.entity.local_position, 1);
                target_position := carrier.entity.local_position + vector;
                new_position := lerp(entity.local_position, target_position, 0.25);
                entity->set_local_position(new_position);
            }
        }

        // Hover animation when picked up
        hover_position := v2{0, 0};
        new_shadow_scale := shadow_scale;
        if is_picked_up {
            shadow_sprite.enabled = true;
            t := PI * get_time();
            hover_position.y = 0.4 + sin(t) * 0.2;
            new_shadow_scale = shadow_scale / (1.0 + hover_position.y);
        }
        else {
            shadow_sprite.enabled = false;
        }
        item_sprite.entity->set_local_position(hover_position);
        item_sprite.depth_offset = -hover_position.y;
        shadow_sprite.entity->set_local_scale(new_shadow_scale);
    }
}

is_player_carrying_item :: proc(player: Player) -> bool {
    foreach item: component_iterator(Carried_Item) {
        if item.carrier == player {
            return true;
        }
    }
    return false;
}

get_player_carried_item :: proc(player: Player) -> Carried_Item {
    foreach item: component_iterator(Carried_Item) {
        if item.carrier == player {
            return item;
        }
    }
    return null;
}

pickup_carried_item :: proc(using item: Carried_Item, player: Player) {
    is_picked_up = true;
    carrier = player;
    if pickup_notification.count > 0 {
        player->add_notification(pickup_notification);
    }
    if pickup_sfx.count > 0 {
        sfx := SFX.default_sfx_desc();
        sfx->set_position(item.entity.world_position);
        sfx.volume_perturb = 0.1;
        sfx.speed_perturb = 0.1;
        SFX.play(get_asset(SFX_Asset, pickup_sfx), sfx);
    }
}

drop_carried_item :: proc(using item: Carried_Item, position: v2) {
    entity->set_local_position(position);
    is_picked_up = false;
    carrier = null;
    if drop_sfx.count > 0 {
        sfx := SFX.default_sfx_desc();
        sfx->set_position(item.entity.world_position);
        sfx.volume_perturb = 0.1;
        sfx.speed_perturb = 0.1;
        SFX.play(get_asset(SFX_Asset, drop_sfx), sfx);
    }
}

//
// Fuel Canister Task
//

Fuel_Spawn_Point :: class : Component {
    // Just a marker component to indicate a potential fuel spawn location
    // Place these around the map in the editor
}

Fuel_Canister :: class : Interactable {
    carried_item: Carried_Item @ao_serialize;

    ao_start :: method() {
        set_listener(this);
        carried_item.pickup_sfx = "sfx/pickup_fuel.wav";
        carried_item.drop_sfx = "sfx/drop_fuel.wav";
        carried_item.pickup_notification = "Bring the fuel canister to the trolley!";
    }

    can_use :: method(player: Player) -> bool {
        return g_game.current_task == .FUEL_CANISTERS
            && player.team == .SURVIVOR
            && !carried_item.is_picked_up
            && !is_player_carrying_item(player);
    }

    on_interact :: method(player: Player) {
        pickup_carried_item(carried_item, player);
    }
}

Fuel_Delivery_Point :: class : Interactable {
    ao_start :: method() {
        set_listener(this);
    }

    can_use :: method(player: Player) -> bool {
        if g_game.current_task != .FUEL_CANISTERS return false;
        if player.team != .SURVIVOR return false;

        // Only usable if the player is carrying a fuel canister
        item := get_player_carried_item(player);
        if item == null return false;

        canister := item.entity->get_component(Fuel_Canister);
        return canister != null;
    }

    on_interact :: method(player: Player) {
        item := get_player_carried_item(player);
        if item == null return;

        canister := item.entity->get_component(Fuel_Canister);
        if canister == null return;

        g_game.fuel_deposited += 1;
        {
            sfx := SFX.default_sfx_desc();
            sfx->set_position(entity.world_position);
            sfx.volume_perturb = 0.2;
            sfx.speed_perturb = 0.1;
            SFX.play(get_asset(SFX_Asset, "sfx/deposit.wav"), sfx);
        }

        // Show fuel on trolley
        if trolley := get_trolley(); trolley != null {
            switch g_game.fuel_deposited {
                case 1: trolley.fuel1_sprite.entity->set_local_enabled(true);
                case 2: trolley.fuel2_sprite.entity->set_local_enabled(true);
                case 3: trolley.fuel3_sprite.entity->set_local_enabled(true);
            }
        }

        // Check if task is complete
        if g_game.fuel_deposited >= REQUIRED_FUEL_CANISTERS {
            foreach p: component_iterator(Player) if p.team == .SURVIVOR {
                p->add_notification("All fuel loaded on trolley!");
            }
            complete_current_task();
        }
        else {
            foreach p: component_iterator(Player) if p.team == .SURVIVOR {
                p->add_notification(format_string("Fuel loaded! (% / %)", {g_game.fuel_deposited, REQUIRED_FUEL_CANISTERS}));
            }
        }

        canister.entity->destroy();
    }
}

//
// Boat Battery Task
//

BATTERY_CHARGE_TIME :: 30.0;

Battery_State :: enum {
    UNCHARGED;
    CHARGING;
    CHARGED;
}

Boat_Battery_Spawn_Point :: class : Component {
    // Marker component for battery spawn locations
}

Boat_Battery :: class : Interactable {
    carried_item: Carried_Item @ao_serialize;

    state: Battery_State;
    charge_t: float;
    charger: Battery_Charger;

    ao_start :: method() {
        set_listener(this);
        carried_item.pickup_sfx = "sfx/pickup_fuel.wav";
        carried_item.drop_sfx = "sfx/drop_fuel.wav";
        state = .UNCHARGED;
    }

    ao_update :: method(dt: float) {
        if g_game.current_task != .CHARGE_BATTERY return;

        if state == .CHARGING {
            // Float towards charger
            entity->lerp_local_position(charger.entity.world_position + v2{0, 0.4}, 15 * dt);

            // Charging progress
            charge_t += dt / BATTERY_CHARGE_TIME;
            if charge_t >= 1 {
                charge_t = 1;
                state = .CHARGED;
                charger.is_charging = false;
                carried_item.pickup_notification = "Bring the charged battery to the trolley!";
                foreach player: component_iterator(Player) if player.team == .SURVIVOR {
                    player->add_notification("Battery fully charged! Bring it to the trolley!");
                }
            }
        }
    }

    ao_late_update :: method(dt: float) {
        if g_game.current_task != .CHARGE_BATTERY return;

        // Draw charging progress bar when charging
        if state == .CHARGING {
            UI.push_world_draw_context();
            defer UI.pop_draw_context();

            options := World_Progress_Bar.default_options();
            World_Progress_Bar.draw(entity.world_position, charge_t, options);
        }
    }

    can_use :: method(player: Player) -> bool {
        if g_game.current_task != .CHARGE_BATTERY return false;
        if player.team != .SURVIVOR return false;
        if is_player_carrying_item(player) return false;

        // Can pick up if uncharged (to bring to charger) or charged (to bring to boat)
        if state == .UNCHARGED && !carried_item.is_picked_up {
            carried_item.pickup_notification = "Bring the battery to the charger!";
            return true;
        }
        if state == .CHARGED && !carried_item.is_picked_up {
            return true;
        }
        return false;
    }

    on_interact :: method(player: Player) {
        pickup_carried_item(carried_item, player);
    }

    start_charging :: method(target_charger: Battery_Charger) {
        state = .CHARGING;
        charger = target_charger;

        // Drop from carrier if being carried
        if carried_item.is_picked_up && carried_item.carrier != null {
            carried_item.is_picked_up = false;
            carried_item.carrier = null;
        }

        foreach player: component_iterator(Player) if player.team == .SURVIVOR {
            player->add_notification("Battery charging... Stay alive!");
        }
    }
}

Battery_Charger :: class : Interactable {
    is_charging: bool;

    ao_start :: method() {
        set_listener(this);
    }

    can_use :: method(player: Player) -> bool {
        if g_game.current_task != .CHARGE_BATTERY return false;
        if player.team != .SURVIVOR return false;
        if is_charging return false;

        // Only usable if the player is carrying an uncharged battery
        item := get_player_carried_item(player);
        if item == null return false;

        battery := item.entity->get_component(Boat_Battery);
        if battery == null return false;

        return battery.state == .UNCHARGED;
    }

    on_interact :: method(player: Player) {
        item := get_player_carried_item(player);
        if item == null return;

        battery := item.entity->get_component(Boat_Battery);
        if battery == null return;

        is_charging = true;
        battery->start_charging(this);

        {
            sfx := SFX.default_sfx_desc();
            sfx->set_position(entity.world_position);
            SFX.play(get_asset(SFX_Asset, "sfx/align_takeoff.wav"), sfx); // TODO: charging sound
        }
    }
}

get_boat_battery :: proc() -> Boat_Battery {
    foreach battery: component_iterator(Boat_Battery) {
        return battery;
    }
    return null;
}

Battery_Delivery_Point :: class : Interactable {
    ao_start :: method() {
        set_listener(this);
    }

    can_use :: method(player: Player) -> bool {
        if g_game.current_task != .CHARGE_BATTERY return false;
        if player.team != .SURVIVOR return false;

        // Only usable if the player is carrying a charged battery
        item := get_player_carried_item(player);
        if item == null return false;

        battery := item.entity->get_component(Boat_Battery);
        if battery == null return false;

        return battery.state == .CHARGED;
    }

    on_interact :: method(player: Player) {
        item := get_player_carried_item(player);
        if item == null return;

        battery := item.entity->get_component(Boat_Battery);
        if battery == null return;

        g_game.battery_delivered = true;
        {
            sfx := SFX.default_sfx_desc();
            sfx->set_position(entity.world_position);
            sfx.volume_perturb = 0.2;
            sfx.speed_perturb = 0.1;
            SFX.play(get_asset(SFX_Asset, "sfx/deposit.wav"), sfx);
        }

        foreach p: component_iterator(Player) if p.team == .SURVIVOR {
            p->add_notification("Battery loaded on trolley!");
        }

        // Show battery on trolley
        if trolley := get_trolley(); trolley != null {
            trolley.battery_sprite.entity->set_local_enabled(true);
        }

        complete_current_task();
        battery.entity->destroy();
    }
}

//
// Payload Trolley
//

TROLLEY_SURVIVOR_RANGE :: 3.0;
TROLLEY_ZOMBIE_RANGE :: 3.0;
TROLLEY_SPEED :: 2.0;

g_trolley: Trolley;

Trolley :: class : Component {
    agent: Movement_Agent @ao_serialize;
    destination: Entity @ao_serialize; // The boat/end point

    sprite: Sprite_Renderer @ao_serialize;
    battery_sprite: Sprite_Renderer @ao_serialize;
    fuel1_sprite: Sprite_Renderer @ao_serialize;
    fuel2_sprite: Sprite_Renderer @ao_serialize;
    fuel3_sprite: Sprite_Renderer @ao_serialize;

    start_position: v2;
    is_being_pushed: bool;
    has_reached_destination: bool;

    ao_start :: method() {
        g_trolley = this;
        agent = entity->get_component(Movement_Agent);
        agent->set_navmesh_to_lock_to(get_game_manager().trolley_navmesh);
        start_position = entity.world_position;
        reset_trolley(this);
    }

    ao_update :: method(dt: float) {
        if g_game.state != .GAMEPLAY return;
        if g_game.current_task != .PUSH_TROLLEY return;
        if has_reached_destination return;

        // Check if any survivor or zombie is in range
        survivor_nearby := false;
        zombie_nearby := false;
        foreach player: component_iterator(Player) {
            if player.health.is_dead continue;
            switch player.team {
                case .SURVIVOR: {
                    if in_range(player.entity.world_position - entity.world_position, TROLLEY_SURVIVOR_RANGE) {
                        survivor_nearby = true;
                    }
                }
                case .ZOMBIE: {
                    if in_range(player.entity.world_position - entity.world_position, TROLLEY_ZOMBIE_RANGE) {
                        zombie_nearby = true;
                    }
                }
            }
        }

        is_being_pushed = survivor_nearby && !zombie_nearby;

        if is_being_pushed {
            // Move toward destination using Movement_Agent pathfinding
            if destination != null && #alive(destination) {
                result := agent->set_path_target(destination.world_position, 60);

                // Flip sprite based on movement direction
                if result.success && sprite != null {
                    new_scale := sprite.entity.local_scale;
                    if result.move_direction.x > 0.01 {
                        new_scale.x = abs(new_scale.x);
                    }
                    else if result.move_direction.x < -0.01 {
                        new_scale.x = -abs(new_scale.x);
                    }
                    sprite.entity->set_local_scale(new_scale);
                }

                // Check if reached destination
                if in_range(entity.world_position - destination.world_position, 0.5) {
                    on_reached_destination();
                }
            }
        }
    }

    ao_late_update :: method(dt: float) {
        if g_game.current_task != .PUSH_TROLLEY return;
        if has_reached_destination return;

        // Draw progress indicator
        UI.push_world_draw_context();
        defer UI.pop_draw_context();

        UI.push_layer(100);
        defer UI.pop_layer();

        // Show push status above trolley
        bar_position := entity.world_position + v2{0, 1.2};

        ts := UI.default_text_settings();
        ts.size = 0.3;

        if is_being_pushed {
            ts.color = {0.2, 1, 0.2, 1};
            UI.text(Rect{bar_position, bar_position}, ts, "PUSHING");
        }
        else {
            // Check why not pushing
            zombie_nearby := false;
            foreach player: component_iterator(Player) {
                if player.team != .ZOMBIE continue;
                if in_range(player.entity.world_position - entity.world_position, TROLLEY_ZOMBIE_RANGE) {
                    zombie_nearby = true;
                    break;
                }
            }

            if zombie_nearby {
                ts.color = {1, 0.2, 0.2, 1};
                UI.text(Rect{bar_position, bar_position}, ts, "CONTESTED");
            }
            else {
                ts.color = {1, 1, 0.2, 1};
                UI.text(Rect{bar_position, bar_position}, ts, "WAITING");
            }
        }
    }

    on_reached_destination :: method() {
        has_reached_destination = true;

        // Hide the trolley sprite and all cargo sprites
        sprite.entity->set_local_enabled(false);
        battery_sprite.entity->set_local_enabled(false);
        fuel1_sprite.entity->set_local_enabled(false);
        fuel2_sprite.entity->set_local_enabled(false);
        fuel3_sprite.entity->set_local_enabled(false);

        foreach p: component_iterator(Player) if p.team == .SURVIVOR {
            p->add_notification("Supplies delivered! Get to the boat!");
        }

        complete_current_task();
    }
}

reset_trolley :: proc(using trolley: Trolley) {
    entity->set_local_position(start_position);
    is_being_pushed = false;
    has_reached_destination = false;

    // Re-enable trolley sprite
    sprite.entity->set_local_enabled(true);

    // Hide all cargo sprites initially
    battery_sprite.entity->set_local_enabled(false);
    fuel1_sprite.entity->set_local_enabled(false);
    fuel2_sprite.entity->set_local_enabled(false);
    fuel3_sprite.entity->set_local_enabled(false);
}

get_trolley :: proc() -> Trolley {
    return g_trolley;
}

is_trolley_being_pushed :: proc() -> bool {
    trolley := get_trolley();
    if trolley == null return false;
    if trolley.has_reached_destination return false;
    return trolley.is_being_pushed;
}

//
// Utils
//

player_set_trigger :: proc(player: Player, trigger: string) {
    player.animator.instance.state_machine->set_trigger(trigger);
}

